<!DOCTYPE html>
<meta charset="utf-8">

<html>
  <script src='https://d3js.org/d3.v5.min.js'></script>
  <script src="https://d3js.org/d3-scale-chromatic.v1.min.js"></script>

  <style> rect {fill: lightblue; stroke: black; }</style>

  <head>
    <title>CS498 Data Visualization Project - msm10</title>
  </head>
  
  <body onload="init()">
    <h1>Atlantic Tropical Cyclones - Accumulated Cyclone Energy (ACE)</h1>
    
    <button onclick="update_ace('ace_sum')">ACE</button>
    <button onclick="update_ace('ace')">Intensity</button>
    <select id="selectYearButton"></select>

    <div id="ace_plot"></div>
    
    <script>
      var all_data
      var margin = {top: 10, right: 100, bottom: 80, left: 50},
        width = 900 - margin.left - margin.right,
        height = 600 - margin.top - margin.bottom;
      
      var svg = d3.select("#ace_plot")
        .append("svg")
          .attr("width", width + margin.left + margin.right)
          .attr("height", height + margin.top + margin.bottom)
        .append("g")
          .attr("transform",
                "translate(" + margin.left + "," + margin.top + ")");
      
      
      
      

      d3.select("body").append("p").html("Page is loaded. About to load spreadsheet...")

      async function init() {
        // Load the csv and get ready to plot some things
        all_data = await d3.csv("https://marchims.github.io/atl_hurricane_1980_2019.csv")

        // Data cleanup and parsing
        var time_parse = d3.timeParse("%m/%d/%Y %H:%M:%S %p")
        all_data.forEach(function(d) {
          d["Iso Time"] = time_parse(d["Iso Time"]) || 0
          d["Formation Date"] = time_parse(d["Formation Date"]) || 0
          d["Dissipation Date"] = time_parse(d["Dissipation Date"]) || 0
          d["Usa Pres"] = +d["Usa Pres"]
          d["Usa Wind"] = +d["Usa Wind"]
        })
        d3.select("body").select("p").html("Page and csv loaded! First SID: " + all_data[0].SID)

        // Keep only 2019 season, for testing


        plot_ace("1980","")
      }

      function get_ace(year, storm) {
        var storm_data
        var year_data
        if (storm == "") {
          // Find all storms by year, get names, then get all storm data for those
          year_data = all_data.filter(function(d) { return d.Season == year && d["Iso Time"] > new Date(0)})
            .sort(function(a,b) { return a["Iso Time"] - b["Iso Time"]; })
          storm = d3.map(year_data, function(d){return d.Name;}).keys()
          year_data = year_data.filter(function(d) { return storm.includes(d.Name)}).sort(function(a,b) { return a["Iso Time"] - b["Iso Time"]; })
        } else {
          // get data for selected storms and year
          year_data = all_data.filter(function(d) { return d["Iso Time"] > new Date(0) && d.Season == year && storm.includes(d.Name)}).sort(function(a,b) { return a["Iso Time"] - b["Iso Time"]; })
        }
        
        var ace_data = []
        var dt
        var t_lim = d3.extent(year_data, function(d) {return d["Iso Time"];})
        var dateRange = d3.timeHour.range(d3.timeDay.floor(t_lim[0]), d3.timeYear.ceil(t_lim[0]),6);
        
        var master_idx = 0
        storm.forEach(function(name,name_idx) {
          // integrate the wind speed for each storm
          storm_data = year_data.filter(function(d) { return name == d.Name})
          console.log("Processing " + name + "...")
          // find start index for first date for this storm, last_t_idx is time when storm starts
          var storm_time_idx = 0

          
          dateRange.forEach(function(t,date_idx,all_dates) {
            
            var wind = 0
            // find the nearest time stamp for current storm
            
            if (storm_time_idx >= storm_data.length || t < storm_data[storm_time_idx]["Iso Time"]) {
              // still before this storm starts
              // do nothing, wind is 0
            } else {
              while (storm_time_idx < storm_data.length && t > storm_data[storm_time_idx]["Iso Time"]) {
                storm_time_idx = storm_time_idx + 1
              }
              if (storm_time_idx < storm_data.length) {
                wind = storm_data[storm_time_idx]["Usa Wind"]
                if (wind < 35 || storm_data[storm_time_idx]["Storm Status"] == "Non-tropical" || storm_data[storm_time_idx]["Iso Date"] == new Date(0)) {
                  wind = 0
                }
                // update the storm's time index
                storm_time_idx = storm_time_idx + 1
              }
              
            }

            ace_data[master_idx] = []
            ace_data[master_idx]["name"] = name
            ace_data[master_idx]["actual_date"] = t
            ace_data[master_idx]["date"] = new Date(t - d3.timeYear.floor(t))
            ace_data[master_idx]["ace"] = 1/10000 * Math.pow(wind,2)
            if (storm_time_idx > 0 && master_idx > 0) {
              ace_data[master_idx]["ace_sum"] = ace_data[master_idx-1]["ace_sum"] + ace_data[master_idx]["ace"]
              if (ace_data[master_idx]["ace"] > 0) {
                ace_data[master_idx]["ace"] = 0.5*ace_data[master_idx]["ace"] + 0.5*ace_data[master_idx-1]["ace"]
              }
            } else {
              ace_data[master_idx]["ace_sum"] = ace_data[master_idx]["ace"]
            }
            master_idx = master_idx + 1
          })
          var p = null
          //ace_data = ace_data.filter(function(d) { return d.date > new Date(0)})
        })
        

        return [storm, ace_data]
      }

      function plot_ace(year, storm) {
        svg.append("g")
          .attr("transform","translate(0,"+height+")")
          .attr("class","ace_xax")
          .selectAll("text")	
          .style("text-anchor", "end")
          .attr("dx", "-.8em")
          .attr("dy", ".15em")
          .attr("transform", "rotate(-65)")
          
        svg.append("g")
          .attr("class","ace_yax")
          
          
        svg.append("text")
          .attr("text-anchor", "middle")
          .attr("transform", "translate(-30,"+((height+margin.top)/2)+")rotate(-90)") 
          .attr("class","ace_yax_label")
          .text("ACE");

        svg.attr("year",year)
          .attr("storm",storm)


        // create a tooltip
        svg.append("text")
          .attr("class","ace_tooltip")
          .attr("x", margin.left)
          .attr("y", margin.top)
          .style("opacity", 0)
          .style("font-size", 17)

        // Create Title
        svg.append("text")
          .attr("class","ace_title")
          .attr("text-anchor", "middle")
          .attr("x", (width / 2))             
          .attr("y", (margin.top / 2))
          .style("font-size", 17)
          .text(year);

        var all_years = d3.map(all_data, function(d){return(d.Season)}).keys().sort()
        // add the options to the button
        d3.select("#selectYearButton")
          .selectAll('year_choices')
          .data(all_years)
          .enter()
          .append('option')
          .text(function (d) { return d; }) // text showed in the menu
          .attr("value", function (d) { return d; }) // corresponding value returned by the button

        // When the button is changed, run the updateChart function
        d3.select("#selectYearButton").on("change", function(d) {
          // recover the option that has been chosen
          var selectedOption = d3.select(this).property("value")
          // run the updateChart function with this selected option
          update_year(selectedOption)
        })

        update_ace("ace_sum")
      }

      function update_year(year) {
        svg.attr("year",year)
        update_ace(svg.attr("plot_type"))
      }

      function update_ace(plot_type) {

        svg.attr("plot_type",plot_type)
        var ace_ = get_ace(svg.attr("year"), svg.attr("storm"))
        var ace = ace_[1]
        var storms = ace_[0]

        

        var line
        var fill = "none"
  
        var keys = Array.from(Array(storms.length-1).keys())
        var color = d3.scaleOrdinal()
          .domain(keys)
          .range(d3.schemeSet2)
        
        var date_fmt = d3.timeFormat("%m/%d/%Y %H:%M:%S")
        var time_parse = d3.timeParse("%m/%d/%Y %H:%M:%S")
        var sum_ace = d3.nest()
          .key(function(d) { return date_fmt(d.date);})
          .entries(ace);

        var ace_stacked = d3.stack()
          .keys(keys)
          .value(function(d, key){
            return d.values[key][plot_type]
          })
          (sum_ace)

        // Axis setup
        var xs = d3.scaleTime()
          .range([0, width])
          .domain([d3.timeYear.floor(ace[0].date),d3.timeYear.ceil(ace[0].date)])
        var ys = d3.scaleLinear()
          .range([height, 0])

        // plot type specifics
        if (plot_type == "ace") {
          svg.selectAll(".ace_yax_label").text("Cyclone Intensity");
          ys.domain([0,5])
        } else {
          svg.selectAll(".ace_yax_label").text("ACE");
          ys.domain([0,280])
        }
        svg.selectAll(".ace_title")
          .text(svg.attr("year") + " Season");

        var xax = d3.axisBottom().scale(xs).tickFormat(d3.timeFormat("%b-%d"))
        svg.selectAll(".ace_xax")
          .transition()
          .duration(1000)
          .call(xax)
          .selectAll("text")	
          .style("text-anchor", "end")
          .attr("dx", "-.8em")
          .attr("dy", ".15em")
          .attr("transform", "rotate(-65)")
        var yax = d3.axisLeft().scale(ys)
        svg.selectAll(".ace_yax").transition()
          .duration(1000)
          .call(yax)
        

        // mouse events
        var ace_mouseover = function(d) {
          svg.selectAll(".ace_tooltip").style("opacity", 1)
          d3.selectAll(".ace_curve").style("opacity", .2)
          d3.select(this)
            .style("stroke", "black")
            .style("opacity", 1)
        }
        var ace_mousemove = function(d,i) {
          grp = storms[i]
          var max_ace
          var py = ys(d3.max(d, function(d) { return d[1]+d[0];} )/2)
          var ace_tooltip = svg.selectAll(".ace_tooltip")
          ace_tooltip.attr("x",width+5)
          ace_tooltip.attr("y",py)
          if (plot_type == "ace") {
            max_ace = d3.max(d, function(d) { return d[1] - d[0];} )
            ace_tooltip.text(grp)
          } else {
            max_ace = d3.max(d, function(d) { return d[1] - d[0];} )
            ace_tooltip.text(grp)
          }
          
        }
        var ace_mouseleave = function(d) {
          svg.selectAll(".ace_tooltip").style("opacity", 0)
          d3.selectAll(".ace_curve")
            .style("opacity", 1)
            .style("stroke", function(d) { return color(d.key); })
        }
        
        var join = svg.selectAll(".ace_curve").data(ace_stacked)
        join.enter()
          .append("path")
          .attr("class","ace_curve")
          .attr("d", d3.area()
            .x(function(d, i) { return xs(time_parse(d.data.key)); })
            .y0(function(d) { return ys(0); })
            .y1(function(d) { return ys(0); })
          )
          .merge(join)
          .on("mouseover", ace_mouseover)
          .on("mouseleave", ace_mouseleave)
          .on("mousemove", ace_mousemove)
          .transition()
          .duration(1000)
          .style("fill", function(d) { return color(d.key); })
          .style("stroke", function(d) { return color(d.key); })
          .attr("d", d3.area()
            .x(function(d, i) { return xs(time_parse(d.data.key)); })
            .y0(function(d) { return ys(d[0]); })
            .y1(function(d) { return ys(d[1]); })
          )
          join.exit()
            .transition()
            .duration(1000)
            .attr("d", d3.area()
              .x(function(d, i) { return xs(time_parse(d.data.key)); })
              .y0(function(d) { return ys(0); })
              .y1(function(d) { return ys(0); })
            )
            .remove()
        }

        /*
        var update_obj = svg.selectAll(".ace_curve").data([ace], function(d) {return d.date;})
        update_obj.enter()
          .append("path")
          .attr("class","ace_curve")
          .merge(update_obj)
          .on("mouseover", ace_mouseover)
          .on("mouseleave", ace_mouseleave)
          .transition()
          .duration(1000)
          .attr("d", line)
          .attr("fill", fill)
          .attr("stroke", "steelblue")
          .attr("stroke-width", 2.5)
          
        }
        */

      function get_storms_by_year(year) {
        var year_data = all_data.filter(function(d) { return d.Season == year})
        year_data = year_data.sort(function(a,b) { return a["Iso Time"] - b["Iso Time"]; })
        return year_data
      }

      function print_max() {
        var max_spd = d3.max(all_data, function(d) {return +d["Usa Wind"];})
        d3.select("body").append("p").html("Max Speed: " + max_spd)
      }

      function print_first_storm_name(data) {
        d3.select("body").append("p").html("First Storm Name (" + data[0]["Iso Time"] + "): " + data[0].Name)
      }

      //function get_max_speed_per_storm(data) {
//
      //}


      /*
      var data = [1,2,4,8,16]
      var width = parseInt(svg.attr("width"))
      var height = parseInt(svg.attr("height"))
      var xs = d3.scaleBand().domain([0,1,2,3,4]).range([0, width-2*margin])
      var ys = d3.scaleLinear().domain([0,20]).range([height-2*margin, 0])
      
      function pick_color(d) {
        var color = "lightblue"
        if (d > 15) {
          color = "red"
        }
        console.log("checking colors for " + d + ":" + color)
        return color
      }

      svg.append("g")
        .attr("transform","translate("+margin+","+margin+")")
        .selectAll("rect")
        .data(data)
        .enter()
        .append("rect")
        .attr("x",function(d,i) {return xs(i)+1;})
        .attr("y",function(d,i) {return ys(0);})
        .attr("width",xs.bandwidth()-5)
        .attr("height",function(d,i) {return height - 2*margin - ys(0);})
        .transition().duration(1000).delay(500)
        .attr("y",function(d,i) {return ys(d);})
        .attr("height",function(d,i) {return height - 2*margin - ys(d);})
        .style("fill",function(d,i) {return pick_color(d);})

      svg.append("g")
        .attr("transform","translate("+margin+","+margin+")")
        .call(d3.axisLeft(ys))
        
      svg.append("g")
        .attr("transform","translate("+margin+","+(height-margin)+")")
        .call(d3.axisBottom(xs))
      */
      
    </script>
    
    
    
  </body>
</html>
